# 依存语法实验笔记

## 生成树

1. 概念：

   生成树就是求解一个把所有节点都连起来的且边数最少的树。所以每一个全连接无向图都至少有一个生成树。

   一个完全无向图，若其节点数为$n$，则有$n^{n-2}$种生成树。

2. 性质：

   - 没有循环
   - 移除任何一边，即为不连通图
   - 增加任何一边，都会产生循环。

3. 数学性质：

   - 若节点有n个，则生成树有n-1个边
   - 对于一个全连接图，最多移除e-n+1个边，就能构造得到生成树

## 最小生成树

1. 在权重图中，最小生成树是权重之和最小的生成树。权重可以是距离，拥堵等

### Kruskal's Spanning Tree Algorithm

1. 目标：

   通过贪心法找出最小生成树。将图看作森林，每一个节点看作一棵树。

2. 算法步骤：

   - 移除所有的循环和平行边中权值较大的
   - 建立一个数组，根据权重升序排列。
   - 向图中增加最小的边，同时要检查生成树的性质成立，如果不成立，则不添加此边
   - 重复第三步

### Prim's Spanning Tree Algorithm

1. 目标：

   使用贪心法找出最小生成树。与Kruskal's方法不同在于将所有节点看成一个单个树，然后从图中选择新的节点到生成树中。

2. 算法步骤：

   - 移除所有的循环和平行边中权值较大的
   - 选择任意节点为根节点
   - 把和树之间距离最小的边，加入到树中
   - 重复第三步

## Chu-LiuEdmonds算法之无环解析

1. 给定有向图：

   ```python
   graph = {‘root’: {‘w0’: 3, ‘w1’: 4, ‘w2’: 3}, ‘w0’: {‘root’: 9, ‘w1’: 30, ‘w2’: 11}, ‘w1’: {‘root’: 10, ‘w0’: 20, ‘w2’: 0}, ‘w2’: {‘root’: 9, ‘w0’: 3, ‘w1’: 30}}
   ```

   外层字典key是依存对中的依赖项，内层字典的key是依存对中的核心词，内层字典的value是依存对的权重，也就是依存对成立的可能性大小。算法的目标是为除了根节点之外的其他词找到核心词。依存图中边由核心词指向依赖项。

2. 算法步骤（对于 **没循环的依存树** ）：

   - 如果有进入根的弧，则将其全部丢弃
   - 对于除根外的每个节点， 择权重最大的输入弧，让所选的n-1个弧成为集合s 

3. 算法步骤（对于 **有循环的依存树** ）：

   